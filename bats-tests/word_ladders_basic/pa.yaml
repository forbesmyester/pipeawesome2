connection:
  input_tap: "f:input | l:letter_count | l:lower_ascii | l:shuf | j:input"
  dict: "j:input | l:dict_protocol | j:funnel"
  start_word: "j:input |C| l:only_one | l:start_protocol | j:funnel"
  debug: "j:funnel | l:combine | l:combine_sort | j:output"
  output: "j:output | d:output"
  # start: "j:input | l:cat | l:only_one | j:output"
  # test_out: "j:funnel | l:it_takes_two | j:output"
  # out_drain: "j:output | d:output"
  # error_seek_exit: "l:it_takes_two[X] | j:output"
  # error_seek_err: "l:it_takes_two[E] | j:output"
  # error_seek_err2: "l:dict_protocol[X] | j:output"
  error_seek_err3: "l:only_one[X] | j:output"
  error_seek_err3: "l:only_one[E] | j:output"
drain:
  output:
    destination: '-'
faucet:
  input:
    source: '/usr/share/dict/words'
launch:
  cat:
    command: "cat"
  dict_protocol:
    command: "awk"
    arg:
      - '-v'
      - 'ID=DICT'
      - &x |
        {
          print ID ":WORD:" $0
          fflush()
        }
        END {
          print ID ":END:"
          fflush()
        }
  start_protocol: { command: "awk", arg: [ '-v', 'ID=BEGIN', *x ] }
  only_one: { command: "head", arg: [ '-n', '1' ] }
  letter_count: { env: { "LC_ALL": "C" }, command: "grep", arg: [ '^....$' ] }
  lower_ascii: { command: "grep", arg: [ '^[a-z]*$' ] }
  shuf: { command: "shuf" }
  combine_sort: { command: "sort", arg: [ "-k", "1,1", "-t", ":", "-s" ] }
  combine:
    command: "awk"
    arg:
      - '-F'
      - ':'
      - |
        $2 != "END" { print $1 ":" $3; }
        $2 == "END" {
          END_COUNT++
          if (END_COUNT >= 2) {
            print "END:"
            exit
          }
        }

